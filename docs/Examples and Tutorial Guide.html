<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Examples and Tutorial Guide &mdash; Phybers 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Documentation" href="Documentation.html" />
    <link rel="prev" title="Requirements and Dependencies" href="Requirements%20and%20Dependencies.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Phybers
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Requirements%20and%20Dependencies.html">Requirements and Dependencies</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Examples and Tutorial Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#how-to-calculate-tractography-from-diffusion-weighted-images-using-dsi-studio-software">How to calculate tractography from diffusion weighted images using DSI Studio software</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conversion-of-tractography-data-to-working-format-trk-o-tck-bundles">Conversion of tractography data to working format (TRK o TCK -&gt; bundles)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-testing-download">Data testing download</a></li>
<li class="toctree-l3"><a class="reference internal" href="#segmentation-example">Segmentation Example</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#visualization-of-segmented-fascicles">Visualization of segmented fascicles</a></li>
<li class="toctree-l4"><a class="reference internal" href="#retrieve-the-fascicles-with-all-points-in-the-subject-s-acquisition-space">Retrieve the fascicles with all points in the subject’s acquisition space</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calculating-intersection-between-fascicles">Calculating intersection between fascicles</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#clustering-example">Clustering Example</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hclust">HClust</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ffclust">FFClust</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="References.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Phybers</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Examples and Tutorial Guide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Examples and Tutorial Guide.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="examples-and-tutorial-guide">
<h1>Examples and Tutorial Guide<a class="headerlink" href="#examples-and-tutorial-guide" title="Permalink to this heading"></a></h1>
<p>This section was created with the purpose of providing a comprehensive example that covers all possible analyses with the Phybers package.
Here, you will find well-commented test codes and data that will allow you to explore many functionalities of the package.</p>
<p>To make the examples more comprehensive, we have decided to start with the <a class="reference internal" href="#testing-data"><span class="std std-ref">How to calculate tractography from diffusion weighted images using DSI Studio software</span></a> subsection,
where we demonstrate how to calculate brain tractography using the DSI Studio software <span id="id1">[<a class="reference internal" href="References.html#id16" title="Fang-Cheng Yeh, Timothy D. Verstynen, Yibao Wang, Juan C. Fernández-Miranda, and Wen-Yih Isaac Tseng. Deterministic Diffusion Fiber Tracking Improved by Quantitative Anisotropy. PLOS ONE, 8(11):e80713, 2013. doi:10.1371/journal.pone.0080713.">1</a>]</span>.
We also provide a tool that allows you to convert tractography from <code class="docutils literal notranslate"><span class="pre">TRK</span></code> (used by DSI Studio, TrackVis, among others) or <code class="docutils literal notranslate"><span class="pre">TCK</span></code> (used by MRtrix and others) formats to the <code class="docutils literal notranslate"><span class="pre">bundles</span></code> format.
Then, in the <a class="reference internal" href="#subsec-example"><span class="std std-ref">Examples</span></a> subsection, we provide test data for running each of the showcased examples, divided into <a class="reference internal" href="#segmentation-example"><span class="std std-ref">Segmentation Example</span></a> and <a class="reference internal" href="#clustering-example"><span class="std std-ref">Clustering Example</span></a>
It’s important to note that completing the <a class="reference internal" href="#testing-data"><span class="std std-ref">How to calculate tractography from diffusion weighted images using DSI Studio software</span></a> subsection is not necessary to try the provided examples.
You can start directly in the <a class="reference internal" href="#data-test-download"><span class="std std-ref">Data testing download</span></a> subsection to run them. Additionally, for detailed documentation on each Phybers module, we recommend accessing the <a class="reference internal" href="Documentation.html#doc-phybers"><span class="std std-ref">Documentation</span></a> section.</p>
<section id="how-to-calculate-tractography-from-diffusion-weighted-images-using-dsi-studio-software">
<span id="testing-data"></span><h2>How to calculate tractography from diffusion weighted images using DSI Studio software<a class="headerlink" href="#how-to-calculate-tractography-from-diffusion-weighted-images-using-dsi-studio-software" title="Permalink to this heading"></a></h2>
<p>Currently, various programs enable the calculation of brain tractography. Nevertheless, in this subsection,
we offer a workflow to obtain brain tractography from diffusion data of a subject in the Human Connectome Project (HCP) database <span id="id2">[<a class="reference internal" href="References.html#id13" title="Matthew F. Glasser, Stamatios N. Sotiropoulos, J. Anthony Wilson, Timothy S. Coalson, Bruce Fischl, Jesper L. Andersson, Junqian Xu, Saad Jbabdi, Matthew Webster, Jonathan R. Polimeni, David C. Van Essen, and Mark Jenkinson. The minimal preprocessing pipelines for the human connectome project. NeuroImage, 80:105-124, 2013. doi:10.1016/j.neuroimage.2013.04.127.">2</a>]</span>, utilizing DSI Studio software.
Subsequently, provide a code to convert the brain tractography from the output format of DSI Studio (<code class="docutils literal notranslate"><span class="pre">TRK</span></code>) to our working format.
This tool is also employed for converting from the <code class="docutils literal notranslate"><span class="pre">TCK</span></code> format to the bundles format, ensuring compatibility with other programs such as MRtrix, among others.</p>
<p>Download and install the DSI Studio software by following the instructions provided on the <a class="reference external" href="https://dsi-studio.labsolver.org/download.html">DSI Studio website</a>.
To perform tractography, acquire preprocessed diffusion data images from an HCP subject, which you can download from the following website:  <a class="reference external" href="https://db.humanconnectome.org/app/template/Login.vm">HCP ConnectomeDB</a></p>
<p>Diffusion data processed through the HCP diffusion pipeline includes diffusion weighting (<code class="docutils literal notranslate"><span class="pre">bvals</span></code>) and direction (<code class="docutils literal notranslate"><span class="pre">bvecs</span></code>) in the same file named (<code class="docutils literal notranslate"><span class="pre">data.nii.gz</span></code>),
a brain mask, a file (<code class="docutils literal notranslate"><span class="pre">grad_dev.nii.gz</span></code>) that can be utilized to address gradient nonlinearities during model fitting, and log files detailing the EDDY processing.
Afterward, you have the option to compute brain tractography with DSI. This can be done through the graphical interface or by using command lines.
If it’s for a single subject, I suggest performing it through the graphical user interface.
To adhere to our workflow (see Figure 1), open the graphical user interface and follow the subsequent 3 steps:</p>
<ul class="simple">
<li><p>Step T1: Open Source Images, allows reading diffusion images in <code class="docutils literal notranslate"><span class="pre">NIfTI</span></code> or <code class="docutils literal notranslate"><span class="pre">DICOM</span></code> format and then creating the <code class="docutils literal notranslate"><span class="pre">SRC</span></code> file.
In this case, the diffusion images are located in the <code class="docutils literal notranslate"><span class="pre">'data.nii.gz'</span></code>.
Subsequently, skull strip techniques and Eddy Current and motion corrections can be applied. Finally, the <code class="docutils literal notranslate"><span class="pre">SRC</span></code> file is created.</p></li>
<li><p>Step T2: Reconstruction, the <code class="docutils literal notranslate"><span class="pre">SRC</span></code> file is read. Afterward, the choice of cerebral tractography reconstruction method is available, with GQI being the selected method in this case.
Finally, the <code class="docutils literal notranslate"><span class="pre">FIB</span></code> file is generated.</p></li>
<li><p>Step T3: Fiber Tracking &amp; Visualization takes the <code class="docutils literal notranslate"><span class="pre">FIB</span></code> file and allows you to adjust parameters for fiber tracking.
In this case, it performs deterministic tractography with the following fiber tracking parameters: angular threshold = <span class="math notranslate nohighlight">\(60^{0}\)</span>, step size = 0.5 <em>mm</em>, smoothing = 0.5, minimum length = 30 <em>mm</em>,
maximum length = 300 <em>mm</em>, and a tract count of 1.5 million fibers.  To conclude, the tractography can be stored in <code class="docutils literal notranslate"><span class="pre">TRK</span></code> format.</p></li>
</ul>
<figure class="align-default" id="id7">
<img alt="pipeline-DSI-Studio.png" src="_images/pipeline-DSI-Studio.png" />
<figcaption>
<p><span class="caption-text">Figure 1. Illustrates the workflow used in DSI Studio to generate brain tractography.
In Step T1, diffusion images are read from <code class="docutils literal notranslate"><span class="pre">NIfTI</span></code> or <code class="docutils literal notranslate"><span class="pre">DICOM</span></code> format, motion and distortion corrections are applied, and the <code class="docutils literal notranslate"><span class="pre">SRC</span></code> file is then built.
Step T2, involves choosing the fiber reconstruction method, leading to the creation of the FIB file. Step T3, enables fiber tracking reconstruction and the saving of tractography in <code class="docutils literal notranslate"><span class="pre">TRK</span></code> format.</span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="conversion-of-tractography-data-to-working-format-trk-o-tck-bundles">
<h2>Conversion of tractography data to working format (TRK o TCK -&gt; bundles)<a class="headerlink" href="#conversion-of-tractography-data-to-working-format-trk-o-tck-bundles" title="Permalink to this heading"></a></h2>
<p>The following code allows you to convert tractography from the <code class="docutils literal notranslate"><span class="pre">TRK</span></code> format (obtained with DSI Studio) to the bundles format.
Additionally, it facilitates the conversion of tractography from the <code class="docutils literal notranslate"><span class="pre">TCK</span></code> format to the bundles format.
In future updates of Phybers, we will provide support for other formats such as <code class="docutils literal notranslate"><span class="pre">VTK</span></code>. To test this tool, Downloads the test <a class="reference external" href="https://www.dropbox.com/scl/fo/vjq9shi9zk8ka0iy3a8wq/h?rlkey=in68fyr37faa86poq9rt60rur&amp;dl=1">dataset</a> to the <code class="docutils literal notranslate"><span class="pre">'Downloads'</span></code> directory on your PC and
then unzip it with the <code class="docutils literal notranslate"><span class="pre">'extract</span> <span class="pre">here'</span></code> option. When reviewing the directory, you will find two files: one named <code class="docutils literal notranslate"><span class="pre">'tractography_format_test.trk'</span></code>, containing 10 thousand brain fibers,
and the other <code class="docutils literal notranslate"><span class="pre">'diffusion_data.nii'</span></code>, which is the diffusion image in the subject’s acquisition space.
This image is used to extract the voxel size and the number of slices necessary to apply the affine transformation and convert the tractography from one format to another.
Next, within the <code class="docutils literal notranslate"><span class="pre">'Downloads/format_conversion_testing'</span></code> directory, create a text file named <code class="docutils literal notranslate"><span class="pre">'format_conversion_tool.py'</span></code>, copy the following code, and save it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import for enabling parallel processing:</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>

<span class="c1"># Import of the nibabel library for handling image file:</span>
<span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nb</span>

<span class="c1"># Import of the NumPy library:</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Import necessary modules from Phybers for writing fiber bundles:</span>
<span class="kn">from</span> <span class="nn">phybers.utils</span> <span class="kn">import</span> <span class="n">write_bundle</span>

<span class="k">def</span> <span class="nf">apply_affine_bundle_parallel</span><span class="p">(</span><span class="n">in_fibers</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Use parallel processing to apply the affine transformation to each fiber.</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># Use parallel processing to apply the affine transformation to each fiber:</span>
   <span class="n">out_fibers</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">nthreads</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">apply_affine_fiber</span><span class="p">)(</span><span class="n">f</span><span class="p">,</span> <span class="n">affine</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">in_fibers</span><span class="p">)</span>

   <span class="k">return</span> <span class="n">out_fibers</span>

<span class="k">def</span> <span class="nf">apply_affine_point</span><span class="p">(</span><span class="n">in_point</span><span class="p">,</span> <span class="n">affine</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Apply an affine transformation to a 3D point.</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># Apply the affine transformation to the input point:</span>
   <span class="n">tmp</span> <span class="o">=</span> <span class="n">affine</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">in_point</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

   <span class="c1"># Extract the transformed point coordinates</span>
   <span class="n">out_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tmp</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

   <span class="k">return</span> <span class="n">out_point</span>

<span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="n">image_reference</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot; Get an affine transformation matrix from an image reference.</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># Load the image reference:</span>
   <span class="n">img_reference</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">image_reference</span><span class="p">)</span>

   <span class="c1"># Get the affine transformation matrix from the image reference:</span>
   <span class="n">affine_</span> <span class="o">=</span> <span class="n">img_reference</span><span class="o">.</span><span class="n">affine</span>

   <span class="c1"># Ensure all values in the affine matrix are positive:</span>
   <span class="n">affine_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">affine_</span><span class="p">)</span>

   <span class="c1"># Apply specific modifications to the diagonal elements and translation vector:</span>
   <span class="n">affine_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
   <span class="n">affine_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
   <span class="n">affine_</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
   <span class="n">affine_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_reference</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">())</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_reference</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">())</span>

   <span class="k">return</span> <span class="n">affine_</span>

<span class="k">def</span> <span class="nf">apply_affine_fiber</span><span class="p">(</span><span class="n">fiber</span><span class="p">,</span> <span class="n">affine</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Apply an affine transformation to a fiber.</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="n">new_fiber</span> <span class="o">=</span> <span class="p">[]</span>

   <span class="c1"># Apply the affine transformation to each point in the fiber:</span>
   <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">fiber</span><span class="p">:</span>
      <span class="n">point_transform</span> <span class="o">=</span> <span class="n">apply_affine_point</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">affine</span><span class="p">)</span>
      <span class="n">new_fiber</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">point_transform</span><span class="p">))</span>

   <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">new_fiber</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">convert_to_bundles</span><span class="p">(</span><span class="n">file_in</span><span class="p">,</span> <span class="n">image_reference</span><span class="p">,</span> <span class="n">file_out_name</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Convert streamlines to bundles and write to file.</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># Get the affine transformation matrix:</span>
   <span class="n">affine</span> <span class="o">=</span> <span class="n">get_affine</span><span class="p">(</span><span class="n">image_reference</span><span class="p">)</span>

   <span class="c1"># Load the streamlines from file:</span>
   <span class="n">fibers</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">streamlines</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_in</span><span class="p">)</span><span class="o">.</span><span class="n">streamlines</span>

   <span class="c1"># Apply the affine transformation to the streamlines in parallel:</span>
   <span class="n">fibers_converted</span> <span class="o">=</span> <span class="n">apply_affine_bundle_parallel</span><span class="p">(</span><span class="n">fibers</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

   <span class="c1"># Write the streamline to bundles format:</span>
   <span class="n">write_bundle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">file_out_name</span><span class="si">}</span><span class="s1">.bundles&#39;</span><span class="p">,</span> <span class="n">fibers_converted</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, to convert from TRK to bundles, at the end of the <code class="docutils literal notranslate"><span class="pre">'format_conversion_tool.py'</span></code> script, add the following lines:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image_reference</span> <span class="o">=</span> <span class="s1">&#39;diffusion_data.nii&#39;</span>
<span class="n">file_in</span><span class="o">=</span> <span class="s1">&#39;tractography_format_test.trk&#39;</span>
<span class="n">file_out_name</span> <span class="o">=</span> <span class="s1">&#39;tractography_format_test_trk&#39;</span>

<span class="n">convert_to_bundles</span><span class="p">(</span><span class="n">file_in</span><span class="p">,</span> <span class="n">image_reference</span><span class="p">,</span> <span class="n">file_out_name</span><span class="p">)</span>
</pre></div>
</div>
<p>Subsequently, run Python to obtain the converted fibers from the <code class="docutils literal notranslate"><span class="pre">TRK</span></code> to bundles format. In the directory <code class="docutils literal notranslate"><span class="pre">'Downloads/format_conversion_testing'</span></code>,
you can verify that the fibers were converted if the following two files are created:
<code class="docutils literal notranslate"><span class="pre">'tractography_format_test_trk.bundles'</span></code> and <code class="docutils literal notranslate"><span class="pre">'tractography_format_test_trk.bundlesdata'</span></code>. To convert from <code class="docutils literal notranslate"><span class="pre">TCK</span></code> to bundles, follow the same procedure.</p>
</section>
<section id="examples">
<span id="subsec-example"></span><h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading"></a></h2>
<p>This subsection provides all the necessary test data to run all the functionalities of Phybers. Two main examples, <a class="reference internal" href="#segmentation-example"><span class="std std-ref">Segmentation Example</span></a> and <a class="reference internal" href="#clustering-example"><span class="std std-ref">Clustering Example</span></a> have been created for this purpose.
The first step would be to obtain the test data from <a class="reference internal" href="#data-test-download"><span class="std std-ref">Data testing download</span></a>,
and then you can run both examples in any order you prefer, as each one is independent of the other.
In the <a class="reference internal" href="#segmentation-example"><span class="std std-ref">Segmentation Example</span></a>, an illustration is given of how the Utils module (<code class="docutils literal notranslate"><span class="pre">deform()</span></code>, <code class="docutils literal notranslate"><span class="pre">sampling()</span></code>,
and <code class="docutils literal notranslate"><span class="pre">intersection()</span></code>) and the visualization module (<code class="docutils literal notranslate"><span class="pre">start_fibervis()</span></code>) integrate with tractography segmentation using the <code class="docutils literal notranslate"><span class="pre">fiberseg()</span></code> algorithm.
In the <a class="reference internal" href="#clustering-example"><span class="std std-ref">Clustering Example</span></a>, an integrative example is presented that allows combining the Utils module (<code class="docutils literal notranslate"><span class="pre">postprocessing()</span></code>) and
the visualization (<code class="docutils literal notranslate"><span class="pre">start_fibervis()</span></code>) with the clustering module’s algorithms <code class="docutils literal notranslate"><span class="pre">hclust()</span></code> and <code class="docutils literal notranslate"><span class="pre">ffclust()</span></code>.
Additionally, tools are provided to analyze clustering results, such as obtaining a histogram of clusters with a size greater than 150 and a length between 50 and 60 <em>mm</em>.</p>
<section id="data-testing-download">
<span id="data-test-download"></span><h3>Data testing download<a class="headerlink" href="#data-testing-download" title="Permalink to this heading"></a></h3>
<p>To run each of the examples provided below, <a class="reference external" href="https://www.dropbox.com/scl/fo/shibujoaqkov3rda5sse2/h?rlkey=4wto6ycw61ozs60mo5kjpibic&amp;dl=1">download the dataset</a>  to the <code class="docutils literal notranslate"><span class="pre">'Downloads'</span></code> directory on your computer,
and then unzip the data using the <code class="docutils literal notranslate"><span class="pre">'extract</span> <span class="pre">here'</span></code> option. This will generate the ‘testing_phybers’ directory, which should contain:
an <code class="docutils literal notranslate"><span class="pre">NIfTI</span></code> image with the nonlinear transformation to deform the tractography to the MNI space (<code class="docutils literal notranslate"><span class="pre">'nonlinear_transform.nii'</span></code>),
and two sets of brain tractographies with their respective <code class="docutils literal notranslate"><span class="pre">'bundles/bundlesdata'</span></code> files. These sets are labeled with the names <code class="docutils literal notranslate"><span class="pre">'subject_15e5.bundles/subject_15e5.bundlesdata'</span></code>
and <code class="docutils literal notranslate"><span class="pre">'subject_16e3.bundles/subject_16e3.bundlesdata'</span></code>.
Both tractographies correspond to the same test subject; their fibers have a variable number of points and are aligned in the subject’s acquisition space.
The only difference is that the first tractography set has a size of 1.5 millons brain fibers, while the second set has 16 thousand brain fibers.
To differentiate them, both are named <code class="docutils literal notranslate"><span class="pre">'subject'</span></code>, followed by the suffix <code class="docutils literal notranslate"><span class="pre">'15e5'</span></code> and <code class="docutils literal notranslate"><span class="pre">'16e3'</span></code>, where <code class="docutils literal notranslate"><span class="pre">'e5'</span></code> represents the power of <span class="math notranslate nohighlight">\(10^{5}\)</span> and <code class="docutils literal notranslate"><span class="pre">'e3'</span></code> represents the power of <span class="math notranslate nohighlight">\(10^{3}\)</span>.
Next, execute the following examples within the <code class="docutils literal notranslate"><span class="pre">'testing_phybers'</span></code>  directory.</p>
</section>
<section id="segmentation-example">
<span id="id3"></span><h3>Segmentation Example<a class="headerlink" href="#segmentation-example" title="Permalink to this heading"></a></h3>
<p>Before applying segmentation, it is crucial that the subject is in the same space as the brain fiber atlas, and that the subject’s fibers have 21 points.
To carry out the segmentation example, follow these three steps:
First, download the test data from the previous subsection  <a class="reference internal" href="#data-test-download"><span class="std std-ref">Data testing download</span></a>.
Second, download the DWM Bundles Atlas (Pamela Guevara 2012) in the subsection <a class="reference internal" href="Documentation.html#atlases-download"><span class="std std-ref">Atlases Download</span></a> to the <code class="docutils literal notranslate"><span class="pre">'testing_phybers'</span></code> directory and then unzip it with the <code class="docutils literal notranslate"><span class="pre">'extract</span> <span class="pre">here'</span></code> option.
You can also use either of the other two SWM atlases provided in the subsection <a class="reference internal" href="Documentation.html#atlases-download"><span class="std std-ref">Atlases Download</span></a>.
Third, create a script file with the name <code class="docutils literal notranslate"><span class="pre">'testing_fiberseg.py'</span></code>, copy the following command lines, save, and execute in a Python terminal within the <code class="docutils literal notranslate"><span class="pre">'testing_phybers'</span></code> directory.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import deform  sub-module. Transforms a tractography file to another space using a non-linear deformation image file:</span>
<span class="kn">from</span> <span class="nn">phybers.utils</span> <span class="kn">import</span> <span class="n">deform</span>

<span class="c1"># Import sampling  sub-module. Performs a sampling of the fibers points:</span>
<span class="kn">from</span> <span class="nn">phybers.utils</span> <span class="kn">import</span> <span class="n">sampling</span>

<span class="c1"># Import fiberseg sub-module. White matter fiber bundle segmentation algorithm based on a multi-subject atlas:</span>
<span class="kn">from</span> <span class="nn">phybers.segment</span> <span class="kn">import</span> <span class="n">fiberseg</span>

<span class="c1">#Execute the deform function:</span>
<span class="n">deform</span> <span class="p">(</span> <span class="n">deform_file</span> <span class="o">=</span> <span class="s1">&#39;nonlinear_transform.nii&#39;</span><span class="p">,</span> <span class="n">file_in</span> <span class="o">=</span> <span class="s1">&#39;subject_15e5.bundles&#39;</span><span class="p">,</span> <span class="n">file_out</span> <span class="o">=</span> <span class="s1">&#39;subject_15e5_MNI.bundles&#39;</span><span class="p">)</span>

<span class="c1"># Execute the sampling function:</span>
<span class="n">sampling</span> <span class="p">(</span> <span class="n">file_in</span> <span class="o">=</span> <span class="s1">&#39;subject_15e5_MNI.bundles&#39;</span><span class="p">,</span> <span class="n">file_out</span> <span class="o">=</span> <span class="s1">&#39;subject_15e5_MNI_21pts.bundles&#39;</span><span class="p">,</span> <span class="n">npoints</span> <span class="o">=</span> <span class="mi">21</span> <span class="p">)</span>

<span class="c1"># Path to the tractography dataset file to segment:</span>
<span class="n">file_in</span> <span class="o">=</span> <span class="s1">&#39;subject_15e5_MNI_21pts.bundles&#39;</span>

<span class="c1"># Subject name used to label the results; in this case, the suffix &#39;15e5&#39; is used:</span>
<span class="n">subj_name</span> <span class="o">=</span> <span class="s1">&#39;15e5&#39;</span>

<span class="c1"># Directory to the bundles atlas:</span>
<span class="n">atlas_dir</span> <span class="o">=</span> <span class="s1">&#39;DWM_atlas_2012/bundles&#39;</span>

<span class="c1"># Path to the atlas information file:</span>
<span class="n">atlas_info</span> <span class="o">=</span> <span class="s1">&#39;DWM_atlas_2012/atlas_info.txt&#39;</span>

<span class="c1"># Directory to save all result segmentation, in this case &#39;seg_result&#39;:</span>
<span class="n">dir_out</span> <span class="o">=</span> <span class="s1">&#39;seg_result&#39;</span>

<span class="c1"># Execute the fiberseg function:</span>
<span class="n">fiberseg</span><span class="p">(</span><span class="n">file_in</span><span class="p">,</span> <span class="n">subj_name</span><span class="p">,</span> <span class="n">atlas_dir</span><span class="p">,</span> <span class="n">atlas_info</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">)</span>
</pre></div>
</div>
<section id="visualization-of-segmented-fascicles">
<h4>Visualization of segmented fascicles<a class="headerlink" href="#visualization-of-segmented-fascicles" title="Permalink to this heading"></a></h4>
<p>The first step to verify that the segmentation was performed correctly would be to open the <code class="docutils literal notranslate"><span class="pre">'seg_result'</span></code> directory and check that the following 3 directories were created:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'seg_result/final_bundles'</span></code>: It contains separately all the segmented fascicles in <code class="docutils literal notranslate"><span class="pre">'bundles/bundlesdata'</span></code> files, sampled at 21 points and in the space of the atlas (MNI).
For example, for the inferior longitudinal fascicle (IL), it should have the following label as the name <code class="docutils literal notranslate"><span class="pre">'15e5_to_IL_LEFT_MNI.bundles/15e5_to_IL_LEFT_MNI.bundlesdata'</span></code>.
This name encodes that we are dealing with the segmentation result for the subject <code class="docutils literal notranslate"><span class="pre">'15e5'</span></code>, specifically for the inferior longitudinal fascicle (IL) in the left hemisphere (LEFT),
and it is located in the MNI space. This idea holds for the rest of the fascicles.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'seg_result/bundles_id'</span></code>: It is a text file containing, for each segmented bundle, the indices of the fibers in the subject’s tractography dataset file.
The name of each file follows the same structure as explained earlier.
These files are used to obtain the segmented fascicles in the subject’s acquisition space and with all points of brain fibers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'seg_result/centroids'</span></code>: A directory containing the centroid of each segmented fascicle, saved in a single file in bundles format,
named <code class="docutils literal notranslate"><span class="pre">'centroids.bundles/centroids.bundlesdata'</span></code>, sampled at 21 points and in the space of the atlas (MNI).</p></li>
</ul>
<p>The second step to check the segmentation results would be to use our visualization software to observe the segmented fascicles.
To do this, execute the following commands in the <code class="docutils literal notranslate"><span class="pre">'Downloads/testing_phybers'</span></code> directory:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import fibervis:</span>
<span class="kn">from</span> <span class="nn">phybers.fibervis</span> <span class="kn">import</span> <span class="n">start_fibervis</span>

<span class="c1"># Execute the graphical user interface for fibervis:</span>
<span class="n">start_fibervis</span><span class="p">()</span>
</pre></div>
</div>
<p>Subsequently, navigate to the directory that stores all segmented bundles, in this case, <code class="docutils literal notranslate"><span class="pre">'seg_result/final_bundles'</span></code>.
Select the 3 segments of the arcuate fasciculus (AR) for the left hemisphere: <code class="docutils literal notranslate"><span class="pre">15e5_to_AR_ANT_LEFT_MNI.bundles</span></code>, <code class="docutils literal notranslate"><span class="pre">15e5_to_AR_ANT_RIGHT_MNI.bundles</span></code>, and <code class="docutils literal notranslate"><span class="pre">15e5_to_AR_LEFT_MNI.bundles</span></code>.
This will allow you to obtain an image similar to the one shown in Figure 2.</p>
<figure class="align-default" id="id8">
<img alt="ARF-seg.png" src="_images/ARF-seg.png" />
<figcaption>
<p><span class="caption-text">Figure 2. Bundle segmentation results for a subject using the DWM Bundles Atlas <span id="id4">[<a class="reference internal" href="References.html#id3" title="P. Guevara, D. Duclap, C. Poupon, L. Marrakchi-Kacem, P. Fillard, D. Le Bihan, M. Leboyer, J. Houenou, and J. F. Mangin. Automatic fiber bundle segmentation in massive tractography datasets using a multi-subject bundle atlas. Neuroimage, 61(4):1083-99, 2012. doi:10.1016/j.neuroimage.2012.02.071.">3</a>]</span>
Three segments of the arcuate fasciculus in the left hemisphere: direct segment (purple), anterior segment (yellow), and posterior segment (green).</span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="retrieve-the-fascicles-with-all-points-in-the-subject-s-acquisition-space">
<h4>Retrieve the fascicles with all points in the subject’s acquisition space<a class="headerlink" href="#retrieve-the-fascicles-with-all-points-in-the-subject-s-acquisition-space" title="Permalink to this heading"></a></h4>
<p>In the <code class="docutils literal notranslate"><span class="pre">'seg_result/final_bundles'</span></code> directory, all detected fascicles in the test subject are stored.
These fascicles have the same number of fiber points, specifically, 21 points, and are located in the atlas space.
In case you need to obtain the fascicles in the same acquisition space as the subject and with the same number of points as the original,
execute the following commands on the <code class="docutils literal notranslate"><span class="pre">'testing_phybers'</span></code> directory.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import Python libraries for additional processing steps:</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Import necessary Phybers modules for fiber reading and writing, respectively:</span>
<span class="kn">from</span> <span class="nn">phybers.utils</span> <span class="kn">import</span> <span class="n">read_bundle</span><span class="p">,</span> <span class="n">write_bundle</span>

<span class="c1"># Reads the fibers with all points and in the subject&#39;s acquisition space:</span>
<span class="n">bundles_allpoint</span> <span class="o">=</span> <span class="n">read_bundle</span><span class="p">(</span><span class="s1">&#39;subject_15e5.bundles&#39;</span><span class="p">)</span>

<span class="c1"># Convert the bundle list into a NumPy array</span>
<span class="n">bundles_allpoint_to_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bundles_allpoint</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

<span class="c1"># Create a directory to store the final bundles with all points</span>
<span class="n">directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span> <span class="p">(</span><span class="s1">&#39;seg_result&#39;</span><span class="p">,</span> <span class="s1">&#39;final_bundles_allpoints&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
   <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>

<span class="c1"># Iterate through files in the &#39;bundles_id/bundles_id&#39; directory</span>
<span class="k">for</span> <span class="n">file_id</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;seg_result&#39;</span><span class="p">,</span> <span class="s1">&#39;bundles_id&#39;</span><span class="p">)):</span>
   <span class="n">indices</span><span class="o">=</span><span class="p">[]</span>

   <span class="c1"># Read indices from the file</span>
   <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;seg_result&#39;</span><span class="p">,</span> <span class="s1">&#39;bundles_id&#39;</span><span class="p">,</span><span class="n">file_id</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())))</span>

   <span class="c1"># Write the fibers with all points to a new bundle file</span>
   <span class="n">write_bundle</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;seg_result&#39;</span><span class="p">,</span><span class="s1">&#39;final_bundles_allpoints&#39;</span><span class="p">,</span><span class="n">file_id</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;.bundles&#39;</span><span class="p">),</span><span class="n">bundles_allpoint_to_array</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="calculating-intersection-between-fascicles">
<h4>Calculating intersection between fascicles<a class="headerlink" href="#calculating-intersection-between-fascicles" title="Permalink to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">phybers.utils</span></code> module includes the <code class="docutils literal notranslate"><span class="pre">'intersection'</span></code> tool, designed to calculate the percentage of overlap between two given fascicles.
This tool proves valuable for evaluating the impact of linear registration versus nonlinear registration on segmented data, as outlined in <span id="id5">Román <em>et al.</em> [<a class="reference internal" href="References.html#id6" title="Claudio Román, Miguel Guevara, Ronald Valenzuela, Miguel Figueroa, Josselin Houenou, Delphine Duclap, Cyril Poupon, Jean-François Mangin, and Pamela Guevara. Clustering of whole-brain white matter short association bundles using hardi data. Frontiers in Neuroinformatics, 11:73, 2017 2017. doi:10.3389/fninf.2017.00073.">4</a>]</span>.
Additionally, it can be employed to identify similarities between the same fascicle across two different subjects.
In this instance, the proposal is to compute the intersection for the fascicle inferior longitudinal fascicle for the left hemisphere,
acquired after segmentation in the previous stage. Thus, <code class="docutils literal notranslate"><span class="pre">'15e5_to_IL_LEFT_MNI.bundles'</span></code> will be passed as an argument for both <code class="docutils literal notranslate"><span class="pre">file1_in</span></code> and <code class="docutils literal notranslate"><span class="pre">file2_in</span></code>.
This allows us to anticipate a 100% intersection result.</p>
<p>To execute an example of <code class="docutils literal notranslate"><span class="pre">phybers.utils.intersection()</span></code> on the recently obtained segmentation results, open a Python terminal in the <code class="docutils literal notranslate"><span class="pre">'testing_phybers'</span></code> directory and run the following commands:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import postprocessing:</span>
<span class="kn">from</span> <span class="nn">phybers.utils</span> <span class="kn">import</span> <span class="n">intersection</span>

<span class="c1"># Import Python library</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Execute the intersection function:</span>
<span class="n">result_intersection</span> <span class="o">=</span> <span class="n">intersection</span> <span class="p">(</span> <span class="n">file1_in</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;seg_result&#39;</span><span class="p">,</span> <span class="s1">&#39;final_bundles&#39;</span><span class="p">,</span> <span class="s1">&#39;15e5_to_IL_LEFT_MNI.bundles&#39;</span><span class="p">),</span>
                                 <span class="n">file2_in</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;seg_result&#39;</span><span class="p">,</span> <span class="s1">&#39;final_bundles&#39;</span><span class="p">,</span> <span class="s1">&#39;15e5_to_IL_LEFT_MNI.bundles&#39;</span><span class="p">),</span>
                                 <span class="n">dir_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;seg_result&#39;</span><span class="p">,</span> <span class="s1">&#39;distance_matrix&#39;</span><span class="p">),</span> <span class="n">distance_thr</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="p">)</span>

<span class="c1"># Display the results of intersection</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Intersection fibers1 with fibers2 &#39;</span><span class="p">,</span> <span class="n">result_intersection</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Intersection fibers2 with fibers1 &#39;</span><span class="p">,</span> <span class="n">result_intersection</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="clustering-example">
<span id="id6"></span><h3>Clustering Example<a class="headerlink" href="#clustering-example" title="Permalink to this heading"></a></h3>
<p>The clustering module includes two clustering algorithms.
First, an example of how to apply <code class="docutils literal notranslate"><span class="pre">'phybers.clustering.hclust()'</span></code> will be presented, followed by an example of <code class="docutils literal notranslate"><span class="pre">'phybers.clustering.ffclust()'</span></code>.
Before carrying out any of the provided examples, download the test data following the instructions given in section <a class="reference internal" href="#data-test-download"><span class="std std-ref">Data testing download</span></a>.</p>
<section id="hclust">
<h4>HClust<a class="headerlink" href="#hclust" title="Permalink to this heading"></a></h4>
<p>Navigate to the <code class="docutils literal notranslate"><span class="pre">'Downloads/testing_phybers'</span></code> directory, open a Python terminal, and execute the commands provided below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import hclust sub-module. Average-link hierarchical agglomerative clustering algorithm:</span>
<span class="kn">from</span> <span class="nn">phybers.clustering</span> <span class="kn">import</span> <span class="n">hclust</span>

<span class="c1"># Path to the tractography dataset file to hclust:</span>
<span class="n">file_in</span> <span class="o">=</span> <span class="s1">&#39;subject_12e3.bundles&#39;</span>

<span class="c1"># Directory to save all result clustering:</span>
<span class="n">dir_out</span> <span class="o">=</span> <span class="s1">&#39;hclust_result&#39;</span>

<span class="c1"># Maximum distance threshold in mm:</span>
<span class="n">fiber_thr</span> <span class="o">=</span> <span class="mi">70</span>

<span class="c1"># Adaptive partition threshold in mm:</span>
<span class="n">partition_thr</span> <span class="o">=</span> <span class="mi">70</span>

<span class="c1"># Variance squared and provides a similarity scale in mm:</span>
<span class="n">variance</span> <span class="o">=</span> <span class="mi">3600</span>

<span class="c1"># Execute the hclust function:</span>
<span class="n">hclust</span> <span class="p">(</span> <span class="n">file_in</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">fiber_thr</span><span class="p">,</span> <span class="n">partition_thr</span><span class="p">,</span> <span class="n">variance</span> <span class="p">)</span>
</pre></div>
</div>
<section id="visualization-of-the-clusters-obtained-with-hclust">
<h5>Visualization of the clusters obtained with HClust<a class="headerlink" href="#visualization-of-the-clusters-obtained-with-hclust" title="Permalink to this heading"></a></h5>
<p>If hclust executed successfully in <code class="docutils literal notranslate"><span class="pre">'Downloads/testing_phybers/hclust_result'</span></code>, you should be able to verify the existence of the following entries:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'final_bundles'</span></code>: Directory that stores all the fiber clusters found in different <code class="docutils literal notranslate"><span class="pre">'bundles/bundlesdata'</span></code> files.
The file names are labeled with integer numbers ranging from zero to the total number of fiber clusters found.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'centroids'</span></code>: Directory that contains the centroid for each created cluster in same <code class="docutils literal notranslate"><span class="pre">'bundles/bundlesdata'</span></code> files.
The firt fiber of bundle centroid is corresponding with centroid calculated for cluster one and so on.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'bundles_id'</span></code>:Text file that stores the fiber index input for each of the detected clusters. The fiber indexes are extracted from the tractography input.
The first line corresponds to cluster zero and so on.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'outputs'</span></code>: Temporal directory with intermediate results.</p></li>
</ul>
<p>Additionally, you can use the visualization module to observe and interact with the obtained results.
First, run the fibervis graphical user interface, and then open the files located in the <code class="docutils literal notranslate"><span class="pre">'Downloads/testing_phybers/hclust_result/final_bundles'</span></code> directory.
To execute fibervis, open a Python terminal in the <code class="docutils literal notranslate"><span class="pre">'Downloads/testing_phybers'</span></code> directory and run the following commands:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import fibervis:</span>
<span class="kn">from</span> <span class="nn">phybers.fibervis</span> <span class="kn">import</span> <span class="n">start_fibervis</span>

<span class="c1"># Execute the graphical user interface for fibervis:</span>
<span class="n">start_fibervis</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="id9">
<img alt="figure-hclust.png" src="_images/figure-hclust.png" />
<figcaption>
<p><span class="caption-text">Figure 3. Results of applying HClust to the whole-brain tractography dataset with 16 thousand streamlines.</span><a class="headerlink" href="#id9" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="ffclust">
<h4>FFClust<a class="headerlink" href="#ffclust" title="Permalink to this heading"></a></h4>
<p>To execute ffclust, find the directory on your computer <code class="docutils literal notranslate"><span class="pre">'Downloads/testing_phybers'</span></code>. Afterward, open a Python terminal and run the following commands:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import the ffclust sub-module. Intra-subject clustering algorithm:</span>
<span class="kn">from</span> <span class="nn">phybers.clustering</span> <span class="kn">import</span> <span class="n">ffclust</span>

<span class="c1"># Import the ffclust sub-module. Intra-subject clustering algorithm:</span>
<span class="kn">from</span> <span class="nn">phybers.utils</span> <span class="kn">import</span> <span class="n">sampling</span>

<span class="c1"># Execute the sampling function:</span>
<span class="n">sampling</span> <span class="p">(</span> <span class="n">file_in</span> <span class="o">=</span> <span class="s1">&#39;subject_15e5.bundles&#39;</span><span class="p">,</span> <span class="n">file_out</span> <span class="o">=</span> <span class="s1">&#39;subject_15e5_21pts.bundles&#39;</span><span class="p">,</span> <span class="n">npoints</span> <span class="o">=</span> <span class="mi">21</span> <span class="p">)</span>

<span class="c1"># Path to the tractography dataset file with 21 points:</span>
<span class="n">file_in</span> <span class="o">=</span> <span class="s1">&#39;subject_15e5_21pts.bundles&#39;</span>

<span class="c1"># Directory to save all segmentation results:</span>
<span class="n">dir_out</span> <span class="o">=</span> <span class="s1">&#39;ffclust_result&#39;</span>

<span class="c1"># Indices of the points to be used in point K-means:</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>

<span class="c1"># Number of clusters to be computed for each point using K-Means:</span>
<span class="n">ks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">]</span>

<span class="c1"># Maximum distance threshold for the cluster reassignment in mm:</span>
<span class="n">assign_thr</span> <span class="o">=</span> <span class="mi">6</span>

<span class="c1"># Maximum distance threshold for cluster merging in mm:</span>
<span class="n">join_thr</span> <span class="o">=</span> <span class="mi">6</span>

<span class="c1"># Execute the ffclust function:</span>
<span class="n">ffclust</span> <span class="p">(</span><span class="n">file_in</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">assign_thr</span><span class="p">,</span> <span class="n">join_thr</span><span class="p">)</span>
</pre></div>
</div>
<section id="ffclust-results-directory">
<h5>FFClust results directory<a class="headerlink" href="#ffclust-results-directory" title="Permalink to this heading"></a></h5>
<p>Once ffclust has been successfully executed in <code class="docutils literal notranslate"><span class="pre">'Downloads/testing_phybers/ffclust_result'</span></code>, you should be able to confirm the presence of the following entries that have the same structure as HClust:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'final_bundles'</span></code>: Directory that stores all the fiber clusters found in different <code class="docutils literal notranslate"><span class="pre">'bundles/bundlesdata'</span></code> files.
The file names are labeled with integer numbers ranging from zero to the total number of fiber clusters found.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'centroids'</span></code>: Directory that contains the centroid for each created cluster in same <code class="docutils literal notranslate"><span class="pre">'bundles/bundlesdata'</span></code> files.
The firt fiber of bundle centroid is corresponding with centroid calculated for cluster one and so on.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'bundles_id'</span></code>:Text file that stores the fiber index input for each of the detected clusters. The fiber indexes are extracted from the tractography input.
The first line corresponds to cluster zero and so on.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'outputs'</span></code>: Temporal directory with intermediate results.</p></li>
</ul>
</section>
<section id="filtering-the-clusters-with-a-size-greater-than-150-and-a-length-in-the-range-from-50-to-60-mm">
<h5>Filtering the clusters with a size greater than 150 and a length in the range from 50 to 60 mm<a class="headerlink" href="#filtering-the-clusters-with-a-size-greater-than-150-and-a-length-in-the-range-from-50-to-60-mm" title="Permalink to this heading"></a></h5>
<p>Useful tool for exploring and evaluating segmentation and clustering results is <code class="docutils literal notranslate"><span class="pre">postprocessing()</span></code> of utils module.
This tool extracts information from clusters, such as size, average length, and intra-cluster distance.
It can then perform various types of filtering, write data, and build a histogram with data distribution.
Following is usage of postprocessing submodule on result obtained after applying <code class="docutils literal notranslate"><span class="pre">ffclust()</span></code>.
First, open Python terminal in <code class="docutils literal notranslate"><span class="pre">'Downloads/testing_phybers/ffclust_result'</span></code> directory, and then execute following command lines.
It’s important to note that each code segment presented should be executed sequentially, as from now on, each code depends on the previous one.
Alternatively, you can copy everything into a Python script and run it all at once.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import postprocessing:</span>
<span class="kn">from</span> <span class="nn">phybers.utils</span> <span class="kn">import</span> <span class="n">postprocessing</span>

<span class="c1"># Import necessary Phybers modules for fiber reading and writing, respectively:</span>
<span class="kn">from</span> <span class="nn">phybers.utils</span> <span class="kn">import</span> <span class="n">read_bundle</span><span class="p">,</span> <span class="n">write_bundle</span>

<span class="c1"># Import Python libraries for additional processing steps:</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Set the input directory</span>
<span class="n">dir_in</span> <span class="o">=</span> <span class="s1">&#39;ffclust_result&#39;</span>

<span class="c1"># Execute postprocessing:</span>
<span class="n">df_metrics</span> <span class="o">=</span> <span class="n">postprocessing</span> <span class="p">(</span><span class="n">dir_in</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">df_metrics</span> <span class="pre">=</span> <span class="pre">postprocessing(dir_in)</span></code> returns a`` Pandas DataFrame`` object that includes the following keys: <code class="docutils literal notranslate"><span class="pre">'size'</span></code> (number of fibers in the bundle),
<code class="docutils literal notranslate"><span class="pre">'len'</span></code> (centroid length per bundle), and ‘<code class="docutils literal notranslate"><span class="pre">intra_mean'</span></code> (mean intra-bundle Euclidean distance).
The DataFrame index corresponds to the cluster number; in other words, the index zero of the dataframe corresponds to cluster zero and centroid zero.</p>
<p>This allows for multiple filters to be applied to the cluster results by manipulating such a well-known data structure as Pandas.
The calculated DataFrame is automatically stored in the directory <code class="docutils literal notranslate"><span class="pre">'ffclust_result/outputs/mensures/mensures.xlsx'</span></code>.</p>
<p>The following code aims to filter the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> stored in df_metrics and then write the detected clusters with the same number of points as the original brain tractography
(which contains a variable number of fibers).
As filtering criteria, it is defined to select clusters with a size greater than or equal to 150 and a length greater than or equal to 40 <em>mm</em> but less than or equal to 60 <em>mm</em>.
To do this, keep the same directory and execute the following commands:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Filtering the clusters with a size greater than 150 and a length in the range from 50 to 60 mm:</span>
<span class="n">filter_df_metrics</span> <span class="o">=</span> <span class="n">df_metrics</span><span class="p">[(</span><span class="n">df_metrics</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">150</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df_metrics</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df_metrics</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">60</span><span class="p">)]</span>

<span class="c1"># List with the indices of filtered fibers:</span>
<span class="n">list_id_fibers_filter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">filter_df_metrics</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

<span class="c1"># Reads the fibers with all points and in the subject&#39;s acquisition space:</span>
<span class="n">bundles</span> <span class="o">=</span> <span class="n">read_bundle</span><span class="p">(</span><span class="s1">&#39;subject_15e5.bundles&#39;</span><span class="p">)</span>

<span class="c1"># Convert bundles to a NumPy array:</span>
<span class="n">bundles_to_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bundles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

<span class="c1"># Define the output directory for filtered bundles:</span>
<span class="n">directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;ffclust_result&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_150S_40-60L&#39;</span><span class="p">)</span>

<span class="c1"># Create the directory if it doesn&#39;t exist:</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
   <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>

<span class="c1"># Read cluster indices from a file and extract indices</span>
<span class="n">dir_id_clusters</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;ffclust_result&#39;</span><span class="p">,</span> <span class="s1">&#39;bundles_id.txt&#39;</span><span class="p">)</span>

<span class="c1"># Initialize a counter to store the cluster numbers:</span>
<span class="n">cont</span><span class="o">=</span><span class="mi">0</span>

<span class="c1"># Initialize a dictionary to store the numbers and indices of the clusters:</span>
<span class="n">dicc</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># Read cluster indices from the file and store them in a dictionary:</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dir_id_clusters</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>

   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>

      <span class="c1"># Initialize an empty list to store the indices of the clusters:</span>
      <span class="n">indices_clusters</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">dicc</span> <span class="p">[</span><span class="n">cont</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
      <span class="n">cont</span><span class="o">+=</span><span class="mi">1</span>

<span class="c1"># Write filtered bundles to separate files based on their indices:</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">list_id_fibers_filter</span><span class="p">:</span>
   <span class="n">write_bundle</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.bundles&#39;</span><span class="p">),</span><span class="n">bundles_to_array</span><span class="p">[</span><span class="n">dicc</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
</pre></div>
</div>
</section>
<section id="visualization-of-the-filtered-clusters">
<h5>Visualization of the filtered clusters<a class="headerlink" href="#visualization-of-the-filtered-clusters" title="Permalink to this heading"></a></h5>
<p>The filtered clusters are stored in the <code class="docutils literal notranslate"><span class="pre">'Downloads/testing_phybers/ffclust_result/filter_150S_40-60L'</span></code> directory.
To visualize them, run the graphical user interface of fibervis using the following command lines and then drag all the bundle files.
This will allow you to obtain an image similar to the one shown in Figure 3.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import fibervis</span>
<span class="kn">from</span> <span class="nn">phybers.fibervis</span> <span class="kn">import</span> <span class="n">start_fibervis</span>

<span class="c1"># Execute the graphical user interface for fibervis:</span>
<span class="n">start_fibervis</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="id10">
<img alt="filter_ffclust_150s_50-60l.png" src="_images/filter_ffclust_150S_50-60L.png" />
<figcaption>
<p><span class="caption-text">Figure 4. Results of applying FFClust to the whole-brain tractography dataset with 1.5 million streamlines.
The detected clusters were filtered using the PostProcessing submodule of the Utils module;
the filtering criterion shows clusters with a size greater than 150 and a length between 50 mm and 60 mm.</span><a class="headerlink" href="#id10" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="histogram-of-the-filtered-clusters">
<h5>Histogram of the filtered clusters<a class="headerlink" href="#histogram-of-the-filtered-clusters" title="Permalink to this heading"></a></h5>
<p>Below is an example that allows you to calculate a histogram to observe the filtered clusters (Figure 4 shows the expected result):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import Seaborn and Matplotlib for creating the histogram:</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Set the bin width for the histogram:</span>
<span class="n">bin_width</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># Find the maximum and minimum values of the &#39;size&#39; column in the DataFrame:</span>
<span class="n">max_lens</span> <span class="o">=</span> <span class="n">filter_df_metrics</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">min_lens</span> <span class="o">=</span> <span class="n">filter_df_metrics</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

<span class="c1"># Create bins with the specified bin width, covering the range from the minimum to maximum &#39;size&#39; values:</span>
<span class="n">bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_lens</span><span class="p">,</span> <span class="n">max_lens</span> <span class="o">+</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_width</span><span class="p">)</span>

<span class="c1"># Create a histogram plot using Seaborn, specifying the data, the &#39;size&#39; column, bins, and visual settings:</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">filter_df_metrics</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>

<span class="c1"># Set the title and labels for the plot:</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Clusters with a size greater than 150 and a length ranging from 50 to 60 *mm*&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Sizes&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>

<span class="c1"># Adjust x-axis tick labels with rotation, alignment, and font size:</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># Add grid lines on the y-axis with a dashed linestyle and reduced alpha (transparency):</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="c1"># Display the histogram plot:</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="id11">
<img alt="filter_ffclust_150s_50-60l.png" src="_images/histplot_sizes.png" />
<figcaption>
<p><span class="caption-text">Figure 5. Histogram constructed to display the sizes of those obtained with FFClust that have a size greater than 150 and a length between 50 mm and 60 mm.</span><a class="headerlink" href="#id11" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Requirements%20and%20Dependencies.html" class="btn btn-neutral float-left" title="Requirements and Dependencies" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Documentation.html" class="btn btn-neutral float-right" title="Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, L.Liset González Rodríguez.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>